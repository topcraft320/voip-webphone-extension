/**
 * DTMF Tone generator based on: http://mamclain.com/?page=RND_SOFTWARE_DTMF_WEB_APP
 * CHANGES:
 *  - 06/09/2017 - Small refactoring in structure and removal of duplicate codes 
 * @author Ricardo JL Rufino
 * @singleton
 */
var DTMFAudio = (function () {

    this.const_DTMF_row_frequency = [1209, 1336, 1477, 1633];
    this.const_DTMF_col_frequency = [697, 770, 852, 941];
    this.const_DTMF_key = ["1", "2", "3", "A", "4", "5", "6", "B", "7", "8", "9", "C", "*", "0", "#", "D"];
    this.const_audio_sample_rate = 44100;
    this.const_sine_samples = 44100;
    this.volume = 0.1;

    this.audioCtx = null;
    this.volCtl = null;
    this.var_DTMF_buffer = new Object();
    this.var_DTMF_mix_list = new Object();
    this.var_Precise_Tone_Plan_buffer = new Object();
    this.var_source = null;

    this.var_dial_isdialing = false;
    this.var_dial_interval = null;
    this.var_dial_time_rate = 40;
    this.var_dial_message = "";
    this.var_dial_message_index = 0;
    this.var_timeout_function = null;

    this.init = function () {
        try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioCtx = new AudioContext();
            this.volCtl = this.audioCtx.createGain();
            this.volCtl.gain.value = this.volume;
            this.volCtl.connect(this.audioCtx.destination)
        }
        catch (e) {
            alert('Web Audio API is not supported in this browser, We recommend You Download a Copy of Mozilla Firefox or Google Chrome!');
        }
        this.PopulateDTMFBuffer();
        this.PopulatePreciseTonePlan();
    }

    this.MakeDTMFSineBuffer = function (frequencyA, frequencyB) {
        var buffer = this.audioCtx.createBuffer(1, this.const_sine_samples, this.const_audio_sample_rate);
        var channel = buffer.getChannelData(0);
        for (i = 0; i < this.const_sine_samples; ++i) {
            channel[i] = Math.sin((frequencyA * 2 * Math.PI * i) / this.const_audio_sample_rate) + Math.sin((frequencyB * 2 * Math.PI * i) / this.const_audio_sample_rate);
        }
        return buffer;
    }

    this.PopulatePreciseTonePlan = function () {

        // Dial Tone

        var aux_samples = this.const_audio_sample_rate * 6;
        var buffer = this.audioCtx.createBuffer(1, aux_samples, this.const_audio_sample_rate);
        var channel = buffer.getChannelData(0);
        var buffer_index = 0;
        var frequencyA = 350;
        var frequencyB = 440;

        var fade_array = new Array();
        var delay_as_sample = Math.floor(this.const_audio_sample_rate * .7); // 2
        var fade_if_value = Math.floor(delay_as_sample * .10);  // 2

        var fillBuffer = function (){

            for (i = 0; i < delay_as_sample; i++) {
                if (i <= fade_if_value) {
                    fade_array[i] = (1.0 / fade_if_value) * i;
                }
                else if (i >= delay_as_sample - fade_if_value - 1) {
                    fade_array[i] = (1.0 / fade_if_value) * (delay_as_sample - (i + 1));
                }
                else {
                    fade_array[i] = 1;
                }
            }
    
            for (i = 0; i < aux_samples; ++i) {
                if (i < delay_as_sample) {
                    channel[i] = fade_array[i] * Math.sin((frequencyA * 2 * Math.PI * i) / this.const_audio_sample_rate) + fade_array[i] * Math.sin((frequencyB * 2 * Math.PI * i) / this.const_audio_sample_rate);
                }
                else {
                    channel[i] = 0;
                }
            }

        };

        fillBuffer.call(this);
        this.var_Precise_Tone_Plan_buffer["dial"] = buffer;

        // Ringback Tone 2x on 4x off
        aux_samples = this.const_audio_sample_rate * 6;
        buffer = this.audioCtx.createBuffer(1, aux_samples, this.const_audio_sample_rate);
        channel = buffer.getChannelData(0);
        buffer_index = 0;
        frequencyA = 440;
        frequencyB = 480;

        fade_array = new Array();
        delay_as_sample = this.const_audio_sample_rate * 2; // 1
        fade_if_value = Math.floor(delay_as_sample * .10); // 1

        fillBuffer.call(this);
        this.var_Precise_Tone_Plan_buffer["ringback"] = buffer;


        // busy tone
        aux_samples = this.const_audio_sample_rate;
        buffer = this.audioCtx.createBuffer(1, aux_samples, this.const_audio_sample_rate);
        channel = buffer.getChannelData(0);
        buffer_index = 0;
        frequencyA = 480;
        frequencyB = 620;

        fade_array = new Array();
        delay_as_sample = Math.floor(this.const_audio_sample_rate * .5); // 2
        fade_if_value = Math.floor(delay_as_sample * .10);  // 2


        fillBuffer.call(this);
        this.var_Precise_Tone_Plan_buffer["busy"] = buffer;


        // reorder tone
        aux_samples = Math.floor(this.const_audio_sample_rate * .5);
        buffer = this.audioCtx.createBuffer(1, aux_samples, this.const_audio_sample_rate);
        channel = buffer.getChannelData(0);
        buffer_index = 0;
        frequencyA = 480;
        frequencyB = 620;

        fade_array = new Array();
        delay_as_sample = Math.floor(aux_samples * .5); // 3
        fade_if_value = Math.floor(delay_as_sample * .10); // 3

        fillBuffer.call(this);
        this.var_Precise_Tone_Plan_buffer["reorder"] = buffer;

        // off-hook tone
        var aux_samples = Math.floor(this.const_audio_sample_rate * .2);
        var buffer = this.audioCtx.createBuffer(1, aux_samples, this.const_audio_sample_rate);
        var channel = buffer.getChannelData(0);
        var buffer_index = 0;
        var frequencyA = 1400;
        var frequencyB = 2060;
        var frequencyC = 2450;
        var frequencyD = 2600;

        var fade_array = new Array();

        var delay_as_sample = Math.floor(aux_samples * .5); // 4

        var fade_if_value = Math.floor(delay_as_sample * .10); // 4

        for (i = 0; i < delay_as_sample; i++) {
            if (i <= fade_if_value) {
                fade_array[i] = (1.0 / fade_if_value) * i;
            }
            else if (i >= delay_as_sample - fade_if_value - 1) {
                fade_array[i] = (1.0 / fade_if_value) * (delay_as_sample - (i + 1));
            }
            else {
                fade_array[i] = 1;
            }
        }

        for (i = 0; i < aux_samples; ++i) {
            if (i < delay_as_sample) {
                channel[i] = fade_array[i] * Math.sin((frequencyA * 2 * Math.PI * i) / this.const_audio_sample_rate) + fade_array[i] * Math.sin((frequencyB * 2 * Math.PI * i) / this.const_audio_sample_rate) + fade_array[i] * Math.sin((frequencyC * 2 * Math.PI * i) / this.const_audio_sample_rate) + fade_array[i] * Math.sin((frequencyD * 2 * Math.PI * i) / this.const_audio_sample_rate);
            }
            else {
                channel[i] = 0;
            }
        }

        this.var_Precise_Tone_Plan_buffer["howler"] = buffer;

    }

    this.PopulateDTMFBuffer = function () {
        buffer_index = 0
        for (lc = 0; lc < this.const_DTMF_col_frequency.length; lc++) {
            for (lr = 0; lr < this.const_DTMF_row_frequency.length; lr++) {
                hash_key = this.const_DTMF_key[buffer_index];
                frequencyA = this.const_DTMF_row_frequency[lr];
                frequencyB = this.const_DTMF_col_frequency[lc];

                this.var_DTMF_buffer[hash_key] = this.MakeDTMFSineBuffer(frequencyA, frequencyB);
                this.var_DTMF_mix_list[hash_key] = new Array(frequencyA, frequencyB);
                buffer_index = buffer_index + 1;
            }
        }
    }

    function createBufferSource() {
        this.var_source = this.audioCtx.createBufferSource();
        if (!this.var_source.start) {
            this.var_source.start = this.var_source.noteOn;
        }
        if (!this.var_source.stop) {
            this.var_source.stop = this.var_source.noteOff;
        }
    }

    this.generateDTMF = function (key) {
        this.stop();
        createBufferSource.call(this);

        this.var_source.loop = true;
        //this.var_source.connect(this.audioCtx.destination);
        this.var_source.connect(this.volCtl);

        this.var_source.buffer = this.var_DTMF_buffer[key];
        this.var_source.start(0);
    }

    this.stopDTMF = function () {
        if (this.var_source != null) {
            this.var_source.stop(0);
        }
    }

    this.stop = function () {
        this.stop_dial_interval();
        if (this.var_source != null) {
            this.var_source.stop(0);
            this.var_source = null;
        }

    }

    this.stop_dial_interval = function () {
        if (this.var_dial_isdialing == true) {
            window.clearInterval(this.var_dial_interval);
            this.var_dial_interval = null;
            if (this.var_source != null) {
                this.var_source.stop(0);
                this.var_source = null;
            }
            this.var_dial_isdialing = false;
        }
        this.var_dial_message = "";
        this.var_dial_message_index = 0;
    }

    this.play = function (key) {
        this.generateDTMF(key);
        _this = this;
        setTimeout(function () {
            _this.stopDTMF();
        }, 100);
    }

    this.playCustom = function (key) {
        if (!(key in this.var_Precise_Tone_Plan_buffer)) {
            alert("Precise Tone has no : " + key);
            return;
        }

        this.stop();
        createBufferSource.call(this);

        this.var_source.loop = true;
        // this.var_source.connect(this.audioCtx.destination);
        this.var_source.connect(this.volCtl);

        buffer = this.var_Precise_Tone_Plan_buffer[key];

        this.var_source.buffer = buffer;
        this.var_source.start(0);
    }

    return this;
}).call({}); // create singleton instance
/* ---------- */
/**
 * AudioVisualizer (Work for local and Remote MediaStream)
 * Reference: https://mdn.github.io/voice-change-o-matic
 * @author Ricardo JL Rufino
 * @singleton
 */
var AudioVisualizer = (function () {

    var started = false;
    var drawVisual; // requestFrame
    var canvas;
    var remoteAudio; // if you use reote
    var analyser;

    /**
     * @param {*} _canva 
     * @param {*} (Optional) _remoteAudio - For WebRCT visualization
     */
    this.init = function (_canvas, _remoteAudio) {
        canvas = _canvas;
        remoteAudio = _remoteAudio;
    }

    this.start = function(){

        if(!canvas) return; // not initialized
        
        // fork getUserMedia for multiple browser versions, for those
        // that need prefixes
        
        navigator.getUserMedia = (navigator.getUserMedia ||
            navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia ||
            navigator.msGetUserMedia);


        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        var source;
        var stream;

        analyser = audioCtx.createAnalyser();
        analyser.minDecibels = -90;
        analyser.maxDecibels = -10;
        analyser.smoothingTimeConstant = 0.85;

        var canvasCtx = canvas.getContext("2d");

        var intendedWidth = canvas.clientWidth;
        var dataArray = null;
        var bufferLength = null;
        var WIDTH = canvas.width;
        var HEIGHT = canvas.height;

        if(remoteAudio){
            console.log("Using provided mediaStream ");
            
            setTimeout(function(){

                if(remoteAudio.srcObject){
                    source = audioCtx.createMediaStreamSource(remoteAudio.srcObject);
                    source.connect(analyser);
                    started = true;
                    visualize();
                }else{
                    console.error("provided mediaStream not active ! ");
                }

            },100);

        }else{ // Use Local Media
            
            console.log("Using local mediaStream ");

            if (navigator.getUserMedia) {
                console.log('getUserMedia supported.');
                navigator.getUserMedia (
                    // constraints - only audio needed for this app
                    {
                        audio: true
                    },
                
                    // Success callback
                    function(stream) {
                        source = audioCtx.createMediaStreamSource(stream);
                        source.connect(analyser);
                        started = true;
                        visualize();
                    },
                
                    // Error callback
                    function(err) {
                        console.log('The following gUM error occured: ' + err);
                        started = false;
                    }
                );
            } else {
                console.log('getUserMedia not supported on your browser!');
                started = false;
            }
        }

        function visualize() {
            analyser.fftSize = 2048;
            bufferLength = analyser.fftSize;

            // dataArray = new Uint8Array(bufferLength);
            dataArray = new Float32Array(bufferLength);
            canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
            draw();
        }


        var draw = function() {
            
            drawVisual = requestAnimationFrame(draw);
        
            //analyser.getByteTimeDomainData(dataArray);
            analyser.getFloatTimeDomainData(dataArray);
            
            canvasCtx.fillStyle = '#56585a';
            canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
        
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#23d160';
        
            canvasCtx.beginPath();
        
            var sliceWidth = WIDTH * 1.0 / bufferLength;
            var x = 0;
        
            for(var i = 0; i < bufferLength; i++) {
                
                var v = dataArray[i] * 150.0;
                var y = HEIGHT/2 + v;
        
                if(i === 0) {
                canvasCtx.moveTo(x, y);
                } else {
                canvasCtx.lineTo(x, y);
                }
        
                x += sliceWidth;
            }
        
            canvasCtx.lineTo(canvas.width, canvas.height/2);
            canvasCtx.stroke();
        };
                
    }

    this.stop = function(){
        if(!canvas) return;
        if(started){
            started = false;
            window.cancelAnimationFrame(drawVisual);
            var canvasCtx = canvas.getContext("2d");
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }

    return this;

}).call({}); // create singleton instance
/* ---------- */

/**
 * Controll calling processes and interact with SIP.js
 */
var CallController = (function () {

    var C = {
        STATUS_NULL:         0,
        STATUS_NEW:          1,
        STATUS_CONNECTING:   2,
        STATUS_CONNECTED:    3,
        STATUS_COMPLETED:    4
    };

    var sipPhone; // SIP.js
    var callListener; // Send notifications to DialPage (call-in, call-out, etc...)

    var accountConfig;

    var public  = {};

    public.init = function (config, listener) {
        accountConfig = config;
        callListener = listener;
        initPhone();
    };

    public.setListener = function (listener) {
        callListener = listener;
    };

    function initPhone(){

        if(sipPhone){
            alert("WARN: OLD call not finished !!");
            return false;
        }
        
        // create audio tag if not exist
        var remoteAudio = document.getElementById("remoteAudio");
        if(!remoteAudio){
            var remoteAudio      = document.createElement('audio');
            remoteAudio.id       = 'remoteAudio';
            document.body.appendChild(remoteAudio);
        }

        var config = {
            uri: accountConfig.username + '@' + accountConfig.domain,
            wsServers: ['wss://' + accountConfig.proxy], // +':7443'
            authorizationUser: accountConfig.user,
            password: accountConfig.password
        };

        try {
            sipPhone = new SIP.WebRTC.Simple({
                media: {
                    remote: {
                        audio: remoteAudio
                    }
                },
                ua: config
            });
        } catch (error) {
            console.error(error);
            alert("ERROR:" +error.message);
            throw error;
        }
    

        window.onunload = onunloadPage;

        sipPhone.on('connected', function(e){ 
            callListener('connected', e);  
            // e.sessionDescriptionHandler.peerConnection
            // if (pc.getRemoteStreams) {
            //     remoteStream = pc.getRemoteStreams()[0];
            //   }
        });
        sipPhone.on('registered', function(e){ 
            callListener('registered', e);  
            localStorage.setItem("sip.registered", true);
        });
        sipPhone.on('unregistered', function(e){ 
            callListener('unregistered', e);  
            localStorage.setItem("sip.registered", false);
        });
        sipPhone.on('registrationFailed', function(e){ 
            callListener('registrationFailed', e); 
            localStorage.setItem("sip.registered", false);
        });
        sipPhone.on('ringing', function(e){ 
            callListener('call-in', e);  
        } );
        sipPhone.on('disconnected', function(e){ 
            callListener('disconnected', e);  
        });
        sipPhone.on('ended', function(e){callListener('ended', e);   });

        // WebSocket events
        sipPhone.ua.on('disconnected', function(e){ callListener('disconnected', e);  });
        sipPhone.ua.on('connecting', function(e){ callListener('connecting', e);  });

        callListener('connecting', sipPhone);  
    }

    public.call = function(number){
        
        var fixed = number.replace(/[^a-zA-Z0-9*#]/g,'')
        sipPhone.call(fixed);

        callListener('call-out', number);
    }

    // Unregister the user agents and terminate all active sessions when the
    // window closes or when we navigate away from the page
    function onunloadPage(){
        // if(sipPhone) sipPhone.stop();
    } 

    public.stop = function(){
        if(sipPhone){
            if(sipPhone.state == 1){ // new
                sipPhone.reject();
            }else{
                sipPhone.hangup();
            }
       }
    } 

    public.disconnect = function(){
        if(sipPhone && sipPhone.state != C.STATUS_NULL){
            console.log("removing old connection");
        }
        delete sipPhone;
        sipPhone = null;
        if(callListener) callListener('disconnected');  
    } 

    public.getState = function(){
        if(sipPhone) return sipPhone.state;
        return null;
    }

    public.sendDTMF = function(key){
        if(sipPhone) return sipPhone.sendDTMF(key);
        return null;
    }

    public.answer = function(){
        if(sipPhone) return sipPhone.answer();
    }

    public.setMute = function(value){
        if(value) sipPhone.mute();
        else sipPhone.unmute();
    }

    public.setHold = function(value){
        if(value) sipPhone.hold();
        else sipPhone.unhold();
    }

         // // 
        // toogleHold: function () {
        //     if(status){
        //          sipPhone.hold();
        //     }
        //  },    
    
    return public;

})();
/* ---------- */
var DialPage = (function () {
    
    var $el = null;
    var $btnCall, $phoneNumber;
    var callActive = false;

    var public  = {};

    public.init = function (el) {
        
        $el = el;

        App.on('call::state_change', onCallStateChange);

        DTMFAudio.init(); // init audio buffers

        $btnCall = $("#btnCall");
        $phoneNumber = $("#phoneNumber");
        $phoneNumber.keyup(function (e) {
            if (e.keyCode == 13) $btnCall.trigger("click");
            if (e.keyCode == 38 || e.keyCode == 40) { // up-down
                $phoneNumber.val(localStorage.getItem('dial.lastNumber'));
            }
        });


        $("#btnMute").on('click', function(){
            var activate = ! ($(this).data('active') || false);
            CallController.setMute(activate);
            $(this).data('active', activate)
            if(activate){
                $(this).removeClass("is-outlined");
            }else{
                $(this).addClass("is-outlined");
            }
        });

        $("#btnHold").on('click', function(){
            var activate = ! ($(this).data('active') || false);
            CallController.setHold(activate);
            $(this).data('active', activate)
            if(activate){
                $(this).removeClass("is-outlined");
            }else{
                $(this).addClass("is-outlined");
            }
        });

        $("#btnStopCall").on('click', function(){
            CallController.stop();
        });
    
        $btnCall.on('click', function(){

            if(callActive){
                CallController.stop();
            }else{
                var number = $phoneNumber.val();
                localStorage.setItem('dial.lastNumber', number);
                CallController.call(number);
            }

        });

        // Play tones
        $("#caller-digits a").click(function(){
            var text = $(this).text();

            DTMFAudio.play(text);

            if(callActive) CallController.sendDTMF(text);
            else{
                $phoneNumber.val($phoneNumber.val() + text);
            }

        });

    };

    public.show = function () {
        // none
    };

    function onCallStateChange(state, e){
        
        var $status = $("#phoneStatus");
        $status.html($loc['status_'+state.replace("-", "_")]);
        $status.attr('class', 'tag phoneStatus-'+state);

        // General status
        if(state == "connected"){
            callActive = true;
            $("footer").addClass('call-active');
            $("#controls-call-active .button").data("active", false); // reset state
        }else{
            callActive = false;
            $("footer").removeClass('call-active');
        }

        // Sound Interactions
        if(state == "call-out"){

            DTMFAudio.playCustom('dial');

        }else if(state == "call-in"){
            
            DTMFAudio.playCustom('ringback');

        }else if(state == "ended"){
            
            DTMFAudio.playCustom('howler');

            setTimeout(function(){
                DTMFAudio.stop();
            },1000);

        }else{
            DTMFAudio.stop();
        }

        // Block keypad and show 
        if(callActive){

            // SHOW CONTROL OPTIONS (MUTE, HOLD, END, TRANSFER) IN NUMBER
            // NUMBERS SEND DTMF TONES
        }
        
    }
    
    return public;

})();
/* ---------- */

var ConfigPage = (function () {
    
    var $el = null;

    var public  = {};

    var listenerStateChange = function(state){

        // Broadcast event
        App.emit('call::state_change', state);

        if(state == 'registered'){
            localStorage.setItem('config.registered',true);
            App.emit('config::registered');
        }

    }
    
    public.init = function (el) {
        $el = el;

        $('form', $el).submit(function(e){

            e.preventDefault();

            var config = {
                username: $($el).find('[name="username"]').val(),
                domain: $($el).find('[name="domain"]').val(),
                proxy: $($el).find('[name="proxy"]').val(),
                password: $($el).find('[name="password"]').val()
            };

            localStorage.setItem('sip.account', JSON.stringify(config));


            CallController.disconnect();
            CallController.init(config, listenerStateChange);

        });


        $('input[type=file]', $el).on('change',loadFromFile);

        $('.btnCancel', $el).click(function(){
            CallController.disconnect();
            localStorage.removeItem('sip.account');
            localStorage.removeItem('config.registered');
            $('form', $el)[0].reset();
        });


    }

    public.show = function () {
        
        loadConfig();

    }

    function loadConfig(){
        var data = localStorage.getItem('sip.account');

        if(data){
            data = JSON.parse(data);
            $.each(data, function(key, value){
                $('[name='+key+']', $el).val(value);
            });
        }
    }

    function loadFromFile(e){
        var oFReader = new FileReader();
        oFReader.readAsBinaryString(e.target.files[0]);
        oFReader.onload = function (oFREvent) {
            localStorage.setItem('sip.account',oFREvent.target.result);
            loadConfig();
        };
    }

    return public;

})();
/* ---------- */
/**
 * @singleton
 */
var AppClass = function () {

    EventEmitter.call(this); // Make App a event-emiter

    // Maximum number of event listeners (used to prevent memory leaks and dumb code) 
    this.maxListeners = 20;


    this.init = function () {

        setupTabs();

        var registered = localStorage.getItem("config.registered");

        if(registered){

            var account = localStorage.getItem("sip.account");
            if (!account) {
                alert($loc.error_no_account);
                return false;
            }

            CallController.init(JSON.parse(account), onCallStateChange);

            DialPage.init($("#DialPage"));

        }else{ 

            $("[data-tab='ConfigPage']").click();

        }

        // Iinit wave form visualizer
        AudioVisualizer.init($('#phone-waveform')[0],$('#remoteAudio')[0]);
        // AudioVisualizer.init($('#phone-waveform')[0]);
        // AudioVisualizer.start();


        // Show dial after configuration
        App.on('config::registered', function () {
            DialPage.init($("#DialPage"));
            CallController.setListener(onCallStateChange);
            
            $("[data-tab='DialPage']").removeAttr('disabled');
            $("[data-tab='DialPage']").click();
        });

        App.on('call::state_change', function (state, e) {

            var $btnCall = $("#btnCall");

            // ===============================    
            //  Footer / Call control
            // ===============================    

            // btnCall state
            if(state == "call-out" || state == "connecting" || state == "connecting"){
                $btnCall.addClass("is-loading");
            }else if(state == "disconnected"){
                $btnCall.removeClass("is-loading");
            }else{
                $btnCall.removeClass("is-loading");
            }

            // Connection status ICON
            if(state == "disconnected"){
                $btnCall.find(".fa").attr('class','fa fa-chain-broken');
                $btnCall.attr("disabled", "disabled");
            }else{
                $btnCall.find(".fa").attr('class','fa fa-phone');
                $btnCall.removeAttr("disabled");
            }

            // ===============================    
            //  Overlay Status control
            // ===============================    

            if (state == "call-out") {

                $("#overlay").addClass("active call-out");

            } else if (state == "call-in") {

                $("#overlay").addClass("active call-in");
                $("#overlay .subtitle").text(e.remoteIdentity.displayName);

            } else {

                $("#overlay").removeClass("active call-in call-out config");

            }

            // Wave
            if (state == "connected") {
                setTimeout(function(){
                    AudioVisualizer.start();
                },1000); // wait for remote media stream
            }else{
                AudioVisualizer.stop();
            }
           
        });


        // Remove overlay on click
        $("#overlay a.button").on('click', function () {
            $("#overlay").removeClass("active call-in call-out config");
        });

        $("#overlay a.cancel").on('click', function () {
            CallController.stop();
        });

        $("#overlay a.answer").on('click', function () {
            CallController.answer();
        });
    }

    function onCallStateChange(state, e){
        // Broadcast event
        App.emit('call::state_change', state, e);
    }

    /**
     * Control Pages / "Routes" 
     */
    function setupTabs(){

        $(".tabs a").click(function(){

            var $this = $(this);

            if($this.is(":disabled") || $this.attr('disabled')) return;

            $(".tabs li").removeClass('is-active');

            $(".tab-content").hide(); // hideall

           

            var tab = $this.data('tab');
            var $tab = $("#"+tab);
            $this.parent().addClass('is-active');

            if($tab.data("loaded")){
                $tab.show();
                eval(tab+".show();"); // Dynamic call show
            }else{
                $tab.load("pages/"+tab+".html",function() {
                    $tab.show();
                    $tab.data("loaded", true);

                    eval(tab+".init($tab);"); // Dynamic call init
                    eval(tab+".show();"); // Dynamic call show

                    // Load translation ($loc)
                    $("[data-localize]", $tab).localize("locales/app");
                });
            }

        });
    }

};

// Extends EventEmitter (event-drive system)
AppClass.prototype = Object.create(EventEmitter.prototype);
AppClass.prototype.constructor = AppClass;
var App = new AppClass();

$(function () {

    // Load translation ($loc)
    $("[data-localize]").localize("locales/app", {
        skipLanguage: "en",
        callback: function (data, fntranslate) {
            window.$loc = data; // global scope
            fntranslate(data);

            App.init();
        }
    });
    
});